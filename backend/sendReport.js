const express = require("express");
const nodemailer = require("nodemailer");
const axios = require("axios");
const { jsPDF } = require("jspdf");
require("jspdf-autotable");
// Workaround for Node.js environment
if (typeof jsPDF.API.autoTable === "undefined") {
  jsPDF.API.autoTable = require("jspdf-autotable");
}
const Papa = require("papaparse");
require("dotenv").config();
const moment = require("moment"); // Add at the top of your file

// Configure your Zoho SMTP credentials
console.log(
  "EMAIL:",
  process.env.ZOHO_EMAIL,
  "PASSWORD:",
  process.env.ZOHO_PASSWORD
);
const transporter = nodemailer.createTransport({
  host: "smtp.zoho.com",
  port: 465,
  secure: true,
  auth: {
    user: process.env.ZOHO_EMAIL,
    pass: process.env.ZOHO_PASSWORD,
  },
});

// Slack webhook URL
const SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;

// Helper to generate PDF from report data
function generatePDF(report) {
  const doc = new jsPDF();
  const margin = 15;
  doc.setFontSize(18);
  doc.setTextColor(34, 139, 34);
  doc.text("VAS Test Report", margin, 20);
  doc.setFontSize(11);
  doc.setTextColor(0, 0, 0);
  doc.text(`Date: ${report.date || new Date().toLocaleString()}`, margin, 28);
  const tableColumn = [
    "Test Name",
    "Status",
    "MSISDN",
    "Click ID",
    "Airtime Before",
    "Airtime After",
  ];
  const formatNaira = (value) => {
    if (!value) return "";
    const str = String(value).trim();
    return str.toLowerCase().endsWith("naira") ? str : `${str} naira`;
  };
  const tableRows = [
    [
      report.testName || "",
      report.status || "",
      report.msisdn || "",
      report.clickId || "",
      formatNaira(report.airtimeBefore),
      formatNaira(report.airtimeAfter),
    ],
  ];
  doc.autoTable({
    head: [tableColumn],
    body: tableRows,
    startY: 35,
    headStyles: { fillColor: [34, 139, 34] },
    styles: { fontSize: 11, cellPadding: 3 },
    margin: { left: margin, right: margin },
  });
  let finalY = doc.lastAutoTable.finalY || 45;
  doc.setFontSize(12);
  doc.setTextColor(0, 0, 0);
  doc.text("Video Recording:", margin, finalY + 12);
  doc.setTextColor(33, 150, 243);
  doc.textWithLink(report.videoRecording || "", margin + 40, finalY + 12, {
    url: report.videoRecording || "",
  });
  doc.setFontSize(9);
  doc.setTextColor(150);
  doc.text("Generated by Naija Test Report Hub", margin, 285);
  return doc.output("arraybuffer");
}

// Helper to generate CSV from report data
function generateCSV(report) {
  return Papa.unparse([report]);
}

async function sendReport(req, res) {
  const { report, format, email, channel } = req.body;
  console.log("Incoming report:", report); // Add this for debugging
  if (!report || !format || !channel)
    return res.status(400).json({ error: "Missing fields" });

  // Move this line here so it's available everywhere
  let rawTimestamp =
    report.timestamp || report.date || new Date().toISOString();

  try {
    if (channel === "email") {
      let attachment, filename;
      // Always use the test report's timestamp or date or fallback to now
      let rawTimestamp =
        report.timestamp || report.date || new Date().toISOString();
      let formattedTimestamp = moment(rawTimestamp, moment.ISO_8601).isValid()
        ? moment(rawTimestamp, moment.ISO_8601).format("DD/MM/YYYY, h:mm:ss A")
        : rawTimestamp;
      let emailBody = `Test Name: ${report.testName}\nStatus: ${report.status}\nMSISDN: ${report.msisdn}\nTimestamp: ${formattedTimestamp}\nClick ID: ${report.clickId}\nAirtime Before: ${report.airtimeBefore}\nAirtime After: ${report.airtimeAfter}`;
      if (report.videoRecording) {
        emailBody += `\nVideo URL: ${report.videoRecording}`;
      }
      let subject = `Test Report: ${report.testName}`;
      if (format === "pdf") {
        attachment = Buffer.from(generatePDF(report));
        filename = "report.pdf";
      } else {
        attachment = Buffer.from(generateCSV(report));
        filename = "report.csv";
      }
      try {
        const mailOptions = {
          from: process.env.ZOHO_EMAIL,
          to: "technicalteam@vdltechnologies.com,product@vdltechnologies.com",
          subject: subject,
          text: emailBody,
          attachments: [
            {
              filename: filename,
              content: attachment,
            },
          ],
        };
        const info = await transporter.sendMail(mailOptions);
        console.log("SMTP Email sent:", info.response);
        return res.json({ success: true });
      } catch (err) {
        console.error("SMTP Email send error:", err);
        return res.status(500).json({ error: err.message });
      }
      // Commented out external API call:
      // try {
      //   const response = await axios.post('http://143.198.240.222:4800/v1/send/email/', { ... });
      //   ...
      // } catch (err) {
      //   ...
      // }
    } else if (channel === "slack") {
      const reportTimestamp = report.timestamp || report.date || "-";
      // For formatting:
      const formattedTimestamp = moment(
        reportTimestamp,
        moment.ISO_8601
      ).isValid()
        ? moment(reportTimestamp, moment.ISO_8601).format(
            "DD/MM/YYYY, h:mm:ss A"
          )
        : reportTimestamp;
      // Use formattedTimestamp in both PDF and email body
      const formattedDate = rawTimestamp
        ? moment(rawTimestamp, moment.ISO_8601).isValid()
          ? moment(rawTimestamp, moment.ISO_8601).format(
              "DD/MM/YYYY, h:mm:ss A"
            )
          : moment().format("DD/MM/YYYY, h:mm:ss A")
        : moment().format("DD/MM/YYYY, h:mm:ss A");
      const testName = report.testName || report.test_name || "-";
      const clickId = report.clickId || report.click_id || "-";
      const airtimeBefore =
        report.airtimeBefore || report.airtime_before || "-";
      const airtimeAfter = report.airtimeAfter || report.airtime_after || "-";
      const videoUrl = report.videoRecording || report.video_url || "";
      const formatNaira = (value) => {
        if (value === "-" || value == null) return "-";
        const str = String(value).trim();
        return str.toLowerCase().endsWith("naira") ? str : `${str} naira`;
      };
      const slackMessage = `*VAS Test Report*\n*Date:* ${formattedDate}\n*Test Name:* ${testName}\n*Status:* ${
        report.status || "-"
      }\n*MSISDN:* ${
        report.msisdn || "-"
      }\n*Click ID:* ${clickId}\n*Airtime Before:* ${formatNaira(
        airtimeBefore
      )}\n*Airtime After:* ${formatNaira(airtimeAfter)}\n${
        videoUrl ? `*Video Recording:* <${videoUrl}|Download>` : ""
      }`;
      try {
        const slackRes = await axios.post(SLACK_WEBHOOK_URL, {
          text: slackMessage,
        });
        if (slackRes.status === 200) {
          return res.json({ success: true });
        } else {
          console.error("Slack API error:", slackRes.status, slackRes.data);
          return res.status(500).json({
            success: false,
            error: "Failed to send Slack message",
            slackResponse: slackRes.data,
          });
        }
      } catch (err) {
        console.error(
          "Slack post error:",
          err.response ? err.response.data : err.message,
          err.stack
        );
        return res.status(500).json({
          error: err.message,
          slackError: err.response ? err.response.data : null,
        });
      }
    } else {
      return res.status(400).json({ error: "Invalid channel" });
    }
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
}

module.exports = { sendReport };
